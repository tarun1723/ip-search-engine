# tice_app_ui.py - Streamlit Dashboard for RICE Threat Intelligence

import streamlit as st
import pandas as pd
import numpy as np
import sys
import os
import re

# --- Fix for Import Error: Add project directory to path ---
# This ensures Python can find tice_api_collector and tice_processor.
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
# -----------------------------------------------------------

# Import the necessary functions from the collector script
try:
    # NOTE: Assuming you moved get_raw_threat_data and process_raw_data to tice_api_collector.py
    from tice_api_collector import get_raw_threat_data, process_raw_data, is_valid_ip
except ImportError as e:
    st.error(
        f"âŒ Error: Could not import core logic from 'tice_api_collector.py'. Details: {e}")
    st.stop()


# --- Page Configuration ---
st.set_page_config(
    page_title="ðŸ›¡ï¸ RICE Threat Intelligence",
    layout="wide",
    initial_sidebar_state="expanded"
)

# --- UI Layout ---

st.title("ðŸ›¡ï¸ RICE: Real-time IP Threat Intelligence Dashboard")
st.markdown("Enter an IPv4 address to collect, process, and visualize threat intelligence data from multiple sources.")

# --- IP Input Slot ---
ip_address = st.text_input(
    "Enter IPv4 Address",
    value="8.8.8.8",
    max_chars=20 # Allow a bit more space for user error
)

# --- Main Logic ---

if st.button("Analyze IP"):
    # Strip any common user errors like periods or whitespace before validation
    ip_address_cleaned = ip_address.strip().rstrip('.')
    
    if not is_valid_ip(ip_address_cleaned):
        st.error(f"âŒ '{ip_address}' is not a valid IPv4 address.")
    else:
        # Show status while processing
        with st.spinner(f"Collecting and analyzing data for **{ip_address_cleaned}**..."):

            # 1. Collect Data
            raw_results = get_raw_threat_data(ip_address_cleaned)

            # 2. Process Data
            try:
                final_report = process_raw_data(ip_address_cleaned, raw_results)
            except Exception as e:
                st.error(f"âŒ Critical error during data processing: {e}")
                st.caption("Raw results dump for debugging:")
                st.json(raw_results)
                st.stop()
        
        # --- Report Display ---

        # 1. Header Metrics (Scorecard)
        col1, col2, col3, col4 = st.columns(4)
        
        # Adjusting status color based on severity
        score = final_report['severity_score']
        if score >= 80:
            status_text = f"HIGH SEVERITY"
            status_color = "red"
        elif score >= 40:
            status_text = f"MEDIUM RISK"
            status_color = "orange"
        else:
            status_text = f"LOW RISK"
            status_color = "green"
        
        # Metrics display
        col1.metric("Reputation", final_report['reputation'])
        col2.metric("Confidence Score", f"{final_report['confidence_score'] * 100:.0f}%")
        col3.metric("Severity Score", f"{score}/100")
        col4.markdown(f"**Overall Status**\n## :{status_color}[{status_text}]")

        st.markdown(f"**Summary:** {final_report['summary']}")

        st.divider()

        # 2. Detailed Data Sections
        tab1, tab2, tab3 = st.tabs(["ðŸŒŽ Geolocation & Network", "ðŸ“Š Scoring Visualization", "ðŸ”— Related IPs & Raw Data"])

        with tab1:
            st.subheader("Geolocation and Network Details")
            geo = final_report.get('geolocation', {})
            
            # Use columns for cleaner side-by-side display
            geo_col1, geo_col2 = st.columns(2)
            
            with geo_col1:
                st.markdown(f"**Organization (ASN):** {geo.get('org', 'N/A')} ({geo.get('asn', 'N/A')})")
                st.markdown(f"**Country/Region:** {geo.get('country', 'N/A')} / {geo.get('region', 'N/A')}")
            
            with geo_col2:
                st.markdown(f"**City:** {geo.get('city', 'N/A')}")
                st.markdown(f"**Hostnames:** {', '.join(geo.get('hostnames', ['N/A']))}")
                
            st.divider()

            # Display Threat Categories
            if final_report['categories']:
                st.warning(f"ðŸš¨ **Threat Categories Identified:** {', '.join(final_report['categories'])}")
            else:
                st.success("No specific threat categories found.")

        with tab2:
            st.subheader("Weighted Scoring Breakdown")

            # Score breakdown is generated by calculate_score in tice_processor.py
            score_breakdown = final_report.get('score_breakdown', {}) 
            
            if score_breakdown:
                df_scores = pd.DataFrame(
                    list(score_breakdown.items()),
                    columns=['Metric', 'Score Contribution']
                ).set_index('Metric')

                st.bar_chart(df_scores, height=300)
                st.markdown(f"**Total Score Contribution:** {sum(df_scores['Score Contribution']):.0f}")
            else:
                st.info("Score breakdown data is not available (Score is 0).")

            st.caption("Bar chart shows the weighted contribution of each source to the final severity score.")
            st.markdown(f"---")
            st.markdown(f"**Data Confidence:** The confidence score reflects the successful connection rate to all APIs.")


        with tab3:
            st.subheader("Raw API Responses (Forensics)")
            
            if final_report.get('raw_api_results'):
                st.json(final_report['raw_api_results'])
            else:
                st.error("No raw data available.")